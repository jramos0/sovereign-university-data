---
term: ЭТИКЕТКА (МОЛЧАЛИВЫЕ ВЫПЛАТЫ)

---
В протоколе Silent Payments метки - это целые числа, используемые для модификации начального статического адреса с целью создания множества других статических адресов. Использование этих меток позволяет разделить платежи, отправляемые через Silent Payments, путем использования различных статических адресов для каждого использования, без чрезмерного увеличения операционной нагрузки для обнаружения этих платежей (сканирование). Боб использует статический адрес $B$, состоящий из двух открытых ключей: $B_{\text{scan}}$ для сканирования и $B_{\text{spend}}$ для трат. Хеш из $b_{\text{scan}}$ и целого числа $m$, скалярно умноженного на генераторную точку $G$, добавляется к открытому ключу трат $B_{\text{spend}}$ для создания как бы нового открытого ключа трат $B_m$:

$$ B_m = B_{\text{spend}} + \text{hash}(b_{\text{scan}} \text{ ‖ } m)\cdot G $$

Например, первый ключ $B_1$ получается таким образом:

$$ B_1 = B_{\text{spend}} + \text{hash}(b_{\text{scan}} \text{ ‖ } 1)\cdot G $$

Теперь статический адрес, опубликованный Бобом, будет состоять из $B_{\text{scan}}$ и $B_m$. Например, первый статический адрес с меткой $1$ будет таким:

$$ B = B_{\text{scan}} \text{ ‖ } B_1 $$

Мы начинаем только с метки $1$, потому что метка $0$ зарезервирована для изменений. Алиса, желающая отправить биткоины на статический адрес с меткой, предоставленный Бобом, выведет уникальный платежный адрес $P_0$, используя новую $B_1$ вместо $B_{\text{spend}}$:

$$ P_0 = B_1 + \text{hash}(\text{inputHash} \cdot a \cdot B_{\text{scan}} \text{ ‖ } 0) \cdot G $$

В действительности Алиса может даже не знать, что у Боба есть адрес с меткой, поскольку она просто использует вторую часть предоставленного им статического адреса, которая в данном случае является значением $B_1$, а не $B_{\text{spend}}$. Для сканирования платежей Боб всегда будет использовать значение своего начального статического адреса с $B_{\text{spend}}$ таким образом:

$$ P_0 = B_{\text{spend}} + \text{hash}(\text{inputHash} \cdot b_{\text{scan}} \cdot A \text{ ‖ } 0) \cdot G $$

Затем он просто вычитает найденное им значение $P_0$ из каждого вывода по очереди. Затем он проверяет, совпадает ли один из результатов этих вычитаний со значением одной из меток, которые он использует на своем кошельке. Если совпадает, например, для вывода № 4 с меткой $1$, это означает, что данный вывод является Silent Payment, связанным с его статическим адресом, обозначенным как $B_1$:

$$ Out_4 - P_0 = \text{hash}(b_{\text{scan}} \text{ ‖ } 1) \cdot G $$

Это работает, потому что:

$$ B_1 = B_{\text{spend}} + \text{hash}(b_{\text{scan}} \text{ ‖ } 1)\cdot G $$

Благодаря этому методу Боб может использовать множество статических адресов (с $B_1$, $B_2$, $B_3$...), каждый из которых является производным от его базового статического адреса ($B = B_{\text{scan}} \text{ ‖ } B_{\text{spend}}$), чтобы правильно разделить использование.

Однако такое разделение статических адресов справедливо только с точки зрения управления личным кошельком, но не позволяет разделить личности. Поскольку все они имеют одинаковый $B_{\text{scan}}$, очень легко связать все статические адреса вместе и сделать вывод, что они принадлежат одному субъекту.